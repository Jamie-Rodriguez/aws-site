<!DOCTYPE html>
<html lang="en-au">
  <head>
    <meta charset="utf-8">

    <title>Jamie’s Site | Projects</title>
    <meta name="description" content="Jamie Rodríguez’s website | Projects">
    <meta name="author" content="Jamie Rodríguez">
    <meta name="date" content="2022-07-29">

    <link rel="stylesheet" type="text/css" href="style.css">

    <link rel="apple-touch-icon" type="image/png" sizes="180x180" href="favicon/favicon-rune180x180.png">
    <link rel="icon" type="image/png" sizes="64x64" href="favicon/favicon-rune64x64.png">
    <link rel="icon" type="image/png" sizes="48x48" href="favicon/favicon-rune48x48.png">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon/favicon-rune32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon/favicon-rune16x16.png">
  </head>
  <body>
    <header>
      <nav aria-label="Site Header">
        <a href="/home">Home</a>
        <a href="/projects">Projects</a>
        <a href="/blog">Blog</a>
        <a href="/contact">Contact</a>
      </nav>
      <hr/>
    </header>

    <p>
      This page gives a brief overview of some projects I have completed. The GitHub repos’ <code>README.md</code> files go into more detail if you are curious.
    </p>

    <h1>Learning to Play Blackjack through <em>Deep Reinforcement Learning</em></h1>
    <p>
      <a href="https://github.com/Jamie-Rodriguez/RL-Blackjack">https://github.com/Jamie-Rodriguez/RL-Blackjack</a>
    </p>
    <p>
      Using OpenAI Gym for the environment, I created an agent that can learn to play blackjack with the most optimal strategy through <em>deep reinforcement learning (RL)</em>.
    </p>
    <p>
      Before moving to full function approximation, I first implemented a tabular method of Monte Carlo sampling. This was to test and ensure that the RL algorithm was functioning correctly, <em>before</em> adding a neural network on top.
    </p>
    <p>
      Once I was satisfied with the RL algorithm, it was time to replace the state-action table with a function approximator - in this case a neural network.
    </p>
    <p>
      The deep reinforcement learning agent was able to converge to the optimal solution, however it took much longer than simpler tabular method. This is an expected cost of using function approximation over tabular methods however.
    </p>
    <p>
      <em>See my GitHub link for more in-depth explanation and analysis.</em>
    </p>

    <h1>4-Clojure; An event-sourced, CQRS banking system written in Clojure</h1>
    <p>
      <a href="https://github.com/Jamie-Rodriguez/4-clojure">https://github.com/Jamie-Rodriguez/4-clojure</a>
    </p>
    <p>
      This is the result of my experimental implementation of an event-sourced (ES), CQRS system. I deliberately wanted to experiment with writing my own ES+CQRS system <em>without a library</em>, in order to gain a deeper understanding of how such systems are designed.
    </p>
    <p>
      I had a small amount of experience with CQRS systems at work that used Elixir and the library called Commanded for CQRS; but I wanted to understand the CQRS architecture and concept at a deeper level. I found that the best way to do this was to write my own system from scratch.
    </p>
    <p>
      I was finding that the CQRS system at work was quite complex and difficult to extend. I wanted to see if I could create a simpler system that was easier to extend and maintain. For this, Clojure was perfect as it is an extremely expressive language and it made prototyping a breeze.
    </p>
    <p>
      In the end, I found that my implementation was very simple and easy to extend compared to the system that I had to use at work. It changed my view that CQRS is not necessarily complex or hard to maintain as I had previously experienced and read online.
    </p>
    <p>
      In the future I might extend this project to have more domain logic/features and also to handle more complex scenarios such as events that may arrive out of order. I may also experiment with different testing strategies for this system.
    </p>

    <h1>Tic-Tac-Clojure; Experiments with AI</h1>
    <p>
      <a href="https://github.com/Jamie-Rodriguez/tic-tac-clojure">https://github.com/Jamie-Rodriguez/tic-tac-clojure</a>
    </p>
    <p>
      Implemented a tic-tac-toe game engine in Clojure, in a purely functional style, using a modern Clojure stack (CLI + Deps).
    </p>
    <p>
      I created this for two reasons:
    </p>
    <ol>
      <li>
        To learn the <em>modern</em>, in-built Clojure development ecosystem, specifically using CLI + Deps with unit testing.
      </li>
      <li>
        To use this engine/environment to experiment with reinforcement learning agents.
      </li>
    </ol>
    <p>
      I then created an AI agent that can play the game. It uses an algorithm called <em>Monte Carlo tree search</em> which, as the name describes, uses the Monte Carlo sampling technique to approximate and then search the game tree.
    </p>
    <p>
      Will probably experiment with more classical reinforcement learning algorithms in the future.
    </p>

    <h1>Lost in <em>Monad’s Land</em> — Monads in C++</h1>
    <p>
      <a href="https://github.com/Jamie-Rodriguez/cpp-monads">https://github.com/Jamie-Rodriguez/cpp-monads</a>
    </p>
    <p>
      What better way to understand how something works than to make one yourself?
    </p>
    <p>
      This repo is the result of me trying to ascertain how the <em>IO</em> monad works. For fun I decided to write it in a language that is the polar-opposite of a purely functional programming language - interestingly it did not turn out as convoluted as I thought.
    </p>
    <p>
      I actually started first by implementing other monads that I already had a decent understanding of their behaviour - <em>Maybe</em> and <em>List</em>, which helped gain a solid general understanding of the monad pattern before applying it to the <em>IO</em> monad.
    </p>

    <h1>Adventures in Modern C Development: HTTP Server</h1>
    <p>
      <a href="https://github.com/Jamie-Rodriguez/c-http-server">https://github.com/Jamie-Rodriguez/c-http-server</a>
    </p>
    <p>
      Minimal example of a HTTP server using the POSIX <em>sockets</em> library, written in C.
    </p>
    <p>
      I created this project simply to see how difficult it is to write a HTTP server using C. Would I recommend it? Unless it is a simple server, I would say… “<em>no</em>”.
    </p>
    <p>
      However I think that this repo is useful as a template for a modern C project that includes unit testing for test-driven development.
    </p>
    <p>
      I organised this project with a more modern, yet minimal project structure; featuring unit testing using the lightweight library <a href="https://github.com/ThrowTheSwitch/Unity">Unity</a>.
    </p>
    <p>
      To remain minimalistic, this project only uses <a href="https://www.gnu.org/software/make/">Make</a> for it’s buildsystem. The <code>makefile</code> makes use of Make’s “<a href="https://www.gnu.org/software/make/manual/html_node/Pattern-Rules.html">pattern rules</a>” so that you don’t need to individually include a file in both the runtime and unit-testing builds every time you add a new file to the project.
    </p>

    <h1>Infrastructure as Code - AWS Static Site</h1>
    <p>
      <a href="https://github.com/Jamie-Rodriguez/aws-site">https://github.com/Jamie-Rodriguez/aws-site</a>
    </p>
    <p>
      AWS Infrastructure as Code to deploy a static site fully automatically (and cheaply). It’s how this site is deployed!
    </p>
    <ul>
      <li>To deploy site: run <code>deploy.sh</code></li>
      <li>To teardown all resources: run <code>teardown.sh</code></li>
    </ul>
    <p>
      See GitHub link for details of the resources and architecture created.
    </p>
  </body>
</html>
